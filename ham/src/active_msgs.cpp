// Copyright (c) 2013-2014 Matthias Noack (ma.noack.pr@gmail.com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

#include <cstring>
#include <iostream>

#include "ham/msg/active_msg_base.hpp"
#include "ham/msg/execution_policy.hpp"
#include "ham/msg/active_msg.hpp"

using namespace std;

namespace ham {
namespace net {

// dummy, as this example does not use any communication backend
node_t this_node() {
	return 0;
}

} // namespace net
} // namespace ham

// some message types, for each of which a message handler is generated and registered

class MsgA : public ham::msg::active_msg<MsgA> {
public:
	void operator()() {
		cout << "MsgA::operator()" << endl;
		// the message could perform some task here
		// and possible send back a result afterwards, e.g. by
		// - using data transferred as member inside the message	
		// - calling some communication layer
		// - ...
	}
	
	// the message could include members that are safe to transfer between the communicating entities
};

class MsgB : public ham::msg::active_msg<MsgB, ham::msg::default_execution_policy> { // same as above (default policy)
public:
	void operator()() {
		cout << "MsgB::operator()" << endl;
	}	
};

class MsgC : public ham::msg::active_msg<MsgC, ham::msg::execution_policy_direct> { // explicitly set an execution policy (you can define your own, e.g. to enqueue messages for a at a runtime component)
public:
	void operator()() {
		cout << "MsgC::operator()" << endl;
	}	
};

// a simple test which simulates a communication channel via memcpy
// of course, this does NOT test the communication between different processes running different binaries 
template<typename Msg>
void test_active_msg(Msg& func)
{
	size_t bufferSize = sizeof(func);
	char* buffer = new char[bufferSize];
	
	// copy to buffer to simulate sending it through a communication channel
	memcpy(buffer, &func, bufferSize);
	
	// simulate reading from the channel, thereby we cast the buffer back to the known base class of all active messages
	auto functor = *reinterpret_cast<ham::msg::active_msg_base*>(buffer);
	
	// This is where the magick happens.
	// Calling the buffer as an active_msg_base functor with the receive buffer
	// as argument triggers a handler look-up, followed by the execution of 
	// that handler (which is defined by the execution policy of the actual 
	// message type). The handler can perform a safe upcast of the buffer to 
	// the actual type of the message and directly execute it as functor, 
	// enqeue it somewhere for further processing, or whatever a policy
	// specifies.
	functor(buffer); 
	
	delete [] buffer;
}

int main() {

	// initialise active message handler address conversion data
	ham::msg::msg_handler_registry::init();

	// print message registry data
	ham::msg::msg_handler_registry::print_handler_map(std::cout); // generated at static-init-time
	ham::msg::msg_handler_registry::print_handler_vector(std::cout); // generated by the init-call above

	// test some simple messages types
	MsgA fA;
	MsgB fB;
	MsgC fC;
	
	test_active_msg(fA);
	test_active_msg(fB);
	test_active_msg(fC);

	return 0;	
}

